<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chroiscraft 3D</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
    }

    /* Health and Hunger Bars */
    .bar {
      position: absolute;
      top: 10px;
      width: 200px;
      height: 20px;
      border: 2px solid #fff;
      background-color: #333;
      margin: 10px;
    }

    .fill {
      height: 100%;
      background-color: red;
      width: 100%;
    }

    /* Inventory */
    #inventory {
      position: absolute;
      top: 40px;
      left: 10px;
      display: flex;
      gap: 10px;
    }

    .slot {
      width: 50px;
      height: 50px;
      border: 1px solid #fff;
      background-color: #333;
      color: white;
      text-align: center;
      line-height: 50px;
    }
  </style>
</head>
<body>
  <!-- Health and Hunger Bars -->
  <div id="health-bar" class="bar">
    <div id="health-fill" class="fill"></div>
  </div>
  <div id="hunger-bar" class="bar" style="top: 40px;">
    <div id="hunger-fill" class="fill"></div>
  </div>

  <!-- Inventory -->
  <div id="inventory">
    <div class="slot" id="slot1">Wood</div>
    <div class="slot" id="slot2">Sand</div>
  </div>

  <!-- Three.js Scene -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, light;
    let health = 100, hunger = 100;
    let inventory = ['wood', 'sand'];
    let player, worldHeightMap = [];

    // Initialize Three.js Scene
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add a directional light with shadows
      light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 5, 5);
      light.castShadow = true;
      scene.add(light);
      
      // Create ground and world generation
      generateWorld();

      // Player (simple cube)
      player = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshLambertMaterial({ color: 0x0000ff }));
      player.position.y = 1;
      player.castShadow = true;
      scene.add(player);

      camera.position.z = 5;
      camera.position.y = 2;

      window.addEventListener('resize', onWindowResize, false);

      animate();
    }

    // Resize the canvas when the window is resized
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Generate the world using Perlin noise
    function generateWorld() {
      const size = 50;
      const scale = 2;
      const noise = new SimplexNoise(); // Or use another noise function if you prefer
      
      for (let x = -size / 2; x < size / 2; x++) {
        worldHeightMap[x] = [];
        for (let z = -size / 2; z < size / 2; z++) {
          const height = Math.floor(noise.noise2D(x / scale, z / scale) * 5); // Random terrain height
          worldHeightMap[x][z] = height;
          addBlock(x, height, z, 'sand');
        }
      }
    }

    // Add a block to the world
    function addBlock(x, y, z, type) {
      let material;
      if (type === 'sand') material = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      else if (type === 'wood') material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      else if (type === 'water') material = new THREE.MeshLambertMaterial({ color: 0x1E90FF });

      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const block = new THREE.Mesh(geometry, material);
      block.position.set(x, y, z);
      block.castShadow = true;
      block.receiveShadow = true;
      scene.add(block);
    }

    // Add an entity (mob) with AI
    function addEntity(x, y, z, type) {
      let material = new THREE.MeshLambertMaterial({ color: type === 'hostile' ? 0xFF0000 : 0x00FF00 });
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const entity = new THREE.Mesh(geometry, material);
      entity.position.set(x, y, z);
      entity.castShadow = true;
      scene.add(entity);

      if (type === 'hostile') {
        // AI to chase player
        entity.behavior = 'hostile';
        entity.move = function() {
          if (this.position.distanceTo(player.position) < 5) {
            this.lookAt(player.position);
            this.position.x += Math.sign(player.position.x - this.position.x) * 0.1;
            this.position.z += Math.sign(player.position.z - this.position.z) * 0.1;
          }
        };
      } else {
        // Friendly mob AI (wandering randomly)
        entity.behavior = 'friendly';
        entity.move = function() {
          this.position.x += Math.random() * 0.1 - 0.05;
          this.position.z += Math.random() * 0.1 - 0.05;
        };
      }
    }

    // Update Health and Hunger Bars
    function updateBars() {
      document.getElementById('health-fill').style.width = `${health}%`;
      document.getElementById('hunger-fill').style.width = `${hunger}%`;
    }

    // Game Loop
    function animate() {
      requestAnimationFrame(animate);

      // Update health and hunger
      hunger -= 0.1;
      if (hunger <= 0) {
        health -= 0.5;
      }

      // Update AI behaviors
      scene.traverse(function(child) {
        if (child.move) {
          child.move();
        }
      });

      // Update health and hunger bars
      updateBars();

      // Render the scene
      renderer.render(scene, camera);
    }

    // Initialize the game
    init();

  </script>
</body>
</html>
